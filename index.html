<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Sort by X8462</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Sort</h1>
        <h2>Sort Comparison</h2>

        <section id="downloads">
          <a href="https://github.com/X8462/sort/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/X8462/sort/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/X8462/sort" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a name="sort-comparison-" class="anchor" href="#sort-comparison-"><span class="octicon octicon-link"></span></a>Sort comparison </h1>

<p>Console App built in C++ to compare various Sorting methods</p>

<ul>
<li>BubbleSort</li>
<li>InsertionSort</li>
<li>QuickSort</li>
<li>ShellSort</li>
<li>MergeSort</li>
</ul><p>For Data in a file that are:</p>

<ul>
<li>Nearly Sorted</li>
<li>Few Unique</li>
<li>Randomly distributed</li>
<li>Reversed</li>
</ul><h2>
<a name="result" class="anchor" href="#result"><span class="octicon octicon-link"></span></a>Result:</h2>

<p><img src="https://raw.github.com/X8462/sort/master/Sorting/Bar%20Graph.png" alt="Result in Bar Graph"></p>

<h2>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h2>

<pre><code>Bubble Sort is quite slow with an O(n2) algorithm for both best case and worst case scenario. Insertion Sort is suited better than Bubble Sort. It works the best when the data is Nearly Sorted. It is also an O(n2) algorithm and is suited better than bubble sorting. As for Quick Sort, it is fast and quick. Its best case algorithm is O(nlog(n)) and worst case is O(n2)- when the numbers are nearly sorted. Quick Sort seemed unworthiness considering the time taken for all types of files although fast wasnâ€™t convincing. Quick Sort was also very unpredictable for Reversed data file. Shell Sort performed faster and convincing for our data size. There was time difference in shell sorting and execution was much faster with the Nearly Sorted data and Reversed Data. Merge was the most predictable and stable sorting method of all. It makes between 0.5log(n) and log(n) comparisons per element and between log n and 1.5log n swaps per element.
</code></pre>

<h2>
<a name="to-clone-this-repo" class="anchor" href="#to-clone-this-repo"><span class="octicon octicon-link"></span></a>To clone this repo:</h2>

<p>git clone git://github.com/X8462/sort.git</p>

<h2>
<a name="to-report-issues" class="anchor" href="#to-report-issues"><span class="octicon octicon-link"></span></a><a href="https://github.com/X8462/sort/issues">To report issues:</a>
</h2>

<p><a href="https://github.com/X8462/sort/issues">https://github.com/X8462/sort/issues</a>
  or,
  email: <a href="mailto:cbijayananda@luc.edu">cbijayananda@luc.edu</a></p>
      </section>
    </div>

    
  </body>
</html>