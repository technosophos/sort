{"name":"Sort","tagline":"Sort Comparison","body":"Sort comparison \r\n===============\r\n\r\n  Console App built in C++ to compare various Sorting methods\r\n\r\n  * BubbleSort\r\n  * InsertionSort\r\n  * QuickSort\r\n  * ShellSort\r\n  * MergeSort\r\n\r\nFor Data in a file that are:\r\n\r\n  * Nearly Sorted\r\n  * Few Unique\r\n  * Randomly distributed\r\n  * Reversed\r\n\r\n\r\nConsole View\r\n-------![Console View](https://raw.github.com/X8462/sort/master/Sorting/ProgramRunProof.png)\r\n\r\n\r\nResult:\r\n--------\r\n\r\n\r\n\r\n![Result in Bar Graph](https://raw.github.com/X8462/sort/master/Sorting/Bar%20Graph.png)\r\n\r\n\r\n\r\nConclusion\r\n---------\r\n    Bubble Sort is quite slow with an O(n2) algorithm for both best case and worst case scenario. Insertion Sort is suited better than Bubble Sort. It works the best when the data is Nearly Sorted. It is also an O(n2) algorithm and is suited better than bubble sorting. As for Quick Sort, it is fast and quick. Its best case algorithm is O(nlog(n)) and worst case is O(n2)- when the numbers are nearly sorted. Quick Sort seemed unworthiness considering the time taken for all types of files although fast wasnâ€™t convincing. Quick Sort was also very unpredictable for Reversed data file. Shell Sort performed faster and convincing for our data size. There was time difference in shell sorting and execution was much faster with the Nearly Sorted data and Reversed Data. Merge was the most predictable and stable sorting method of all. It makes between 0.5log(n) and log(n) comparisons per element and between log n and 1.5log n swaps per element.\r\n    \r\n    \r\nTo clone this repo:\r\n----------\r\n  git clone git://github.com/X8462/sort.git\r\n  \r\n  \r\n[To report issues:](https://github.com/X8462/sort/issues)\r\n----------------\r\n  https://github.com/X8462/sort/issues\r\n  or,\r\n  email: cbijayananda@luc.edu\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
